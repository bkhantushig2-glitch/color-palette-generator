<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Palette Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f0f1a;
            --bg-alt: #1a1a2e;
            --text: #eee;
            --text-muted: #999;
            --text-dim: #555;
            --border: rgba(255,255,255,0.08);
            --border-hover: rgba(255,255,255,0.2);
            --surface: rgba(255,255,255,0.05);
            --surface-hover: rgba(255,255,255,0.1);
            --overlay: rgba(0,0,0,0.5);
            --toast-bg: rgba(20,20,35,0.9);
            --paint-fade: 15, 15, 26;
            transition: all 0.4s ease;
        }

        [data-theme="light"] {
            --bg: #f0f0f5;
            --bg-alt: #ffffff;
            --text: #222;
            --text-muted: #666;
            --text-dim: #999;
            --border: rgba(0,0,0,0.1);
            --border-hover: rgba(0,0,0,0.25);
            --surface: rgba(0,0,0,0.04);
            --surface-hover: rgba(0,0,0,0.08);
            --overlay: rgba(0,0,0,0.3);
            --toast-bg: rgba(255,255,255,0.95);
            --paint-fade: 240, 240, 245;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            height: 100vh;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background 0.4s ease, color 0.4s ease;
        }

        /* ── Toolbar ── */
        .toolbar {
            height: 52px;
            min-height: 52px;
            background: var(--bg);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 1.2rem;
            gap: 0.6rem;
            z-index: 100;
            transition: background 0.4s ease;
        }

        .toolbar-logo {
            font-size: 1.1rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 300% 300%;
            animation: gradientShift 4s ease infinite;
            margin-right: auto;
            white-space: nowrap;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .toolbar-btn {
            padding: 0.35rem 0.7rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.72rem;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .toolbar-btn:hover { background: var(--surface-hover); color: var(--text); }
        .toolbar-btn.active { background: var(--surface-hover); color: var(--text); border-color: var(--border-hover); }

        .toolbar-btn.paint-btn {
            background: linear-gradient(135deg, rgba(255,107,107,0.2), rgba(72,219,251,0.2));
            border-color: var(--border-hover);
            color: var(--text-muted);
        }
        .toolbar-btn.paint-btn:hover {
            background: linear-gradient(135deg, rgba(255,107,107,0.35), rgba(72,219,251,0.35));
            color: var(--text);
        }
        .toolbar-btn.paint-btn.active {
            background: linear-gradient(135deg, rgba(255,107,107,0.5), rgba(72,219,251,0.5));
            border-color: var(--border-hover);
        }

        .toolbar select {
            padding: 0.35rem 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-muted);
            font-size: 0.72rem;
            cursor: pointer;
            outline: none;
        }
        .toolbar select option { background: var(--bg-alt); color: var(--text); }

        .toolbar-hint {
            font-size: 0.62rem;
            color: var(--text-dim);
        }
        .toolbar-hint kbd {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 0.1rem 0.35rem;
            font-family: inherit;
            font-size: 0.58rem;
        }

        .toolbar-sep {
            width: 1px;
            height: 24px;
            background: var(--border);
        }

        .theme-toggle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--surface);
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .theme-toggle:hover { background: var(--surface-hover); transform: rotate(30deg); }

        /* ── Strips Container ── */
        .strips-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .color-strip {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: flex 0.3s ease;
            cursor: default;
            min-width: 0;
        }

        .strip-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .color-strip:hover .strip-content { opacity: 1; pointer-events: auto; }

        .strip-hex {
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            cursor: pointer;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            transition: background 0.15s ease;
        }
        .strip-hex:hover { background: rgba(0,0,0,0.15); }

        .strip-actions {
            display: flex;
            gap: 0.4rem;
        }

        .strip-action {
            width: 34px;
            height: 34px;
            border-radius: 8px;
            border: none;
            background: rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            font-size: 0.95rem;
        }
        .strip-action:hover { background: rgba(0,0,0,0.35); transform: scale(1.1); }
        .strip-action.locked { background: rgba(255,255,255,0.2); }

        .strip-drag {
            width: 34px;
            height: 34px;
            border-radius: 8px;
            border: none;
            background: rgba(0,0,0,0.2);
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            font-size: 0.85rem;
            letter-spacing: 2px;
        }
        .strip-drag:hover { background: rgba(0,0,0,0.35); transform: scale(1.1); }
        .strip-drag:active { cursor: grabbing; }

        .color-strip.dragging { opacity: 0.4; }
        .color-strip.drag-over-left { box-shadow: inset 4px 0 0 0 rgba(255,255,255,0.6); }
        .color-strip.drag-over-right { box-shadow: inset -4px 0 0 0 rgba(255,255,255,0.6); }

        /* ── Contrast Badge ── */
        .strip-contrast {
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            letter-spacing: 0.05em;
        }
        .contrast-pass { background: rgba(46,213,115,0.25); color: #2ed573; }
        .contrast-fail { background: rgba(255,71,87,0.25); color: #ff4757; }

        /* ── Add Color Buttons ── */
        .add-btn {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            background: rgba(15, 15, 26, 0.8);
            color: rgba(255,255,255,0.5);
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            transition: all 0.2s ease;
        }
        .strips-container:hover .add-btn { opacity: 1; }
        .add-btn:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
            border-color: rgba(255,255,255,0.4);
            transform: translate(-50%, -50%) scale(1.15);
        }

        /* ── Picker Modal ── */
        .picker-backdrop {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--overlay);
            z-index: 200;
            display: none;
        }
        .picker-backdrop.active { display: block; }

        .picker-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-alt);
            border-radius: 16px;
            border: 1px solid var(--border);
            padding: 1.5rem;
            z-index: 201;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            transition: background 0.4s ease;
        }
        .picker-modal.active { display: flex; }

        .picker-modal-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-dim);
        }

        .picker-layout {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .hue-ring-container {
            position: relative;
            width: 220px;
            height: 220px;
        }

        .hue-ring { border-radius: 50%; cursor: crosshair; }

        .hue-indicator {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .sl-square {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 4px;
            cursor: crosshair;
            border: 2px solid var(--border);
        }

        .sl-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .picker-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 160px;
        }

        .picker-preview {
            width: 100%;
            height: 60px;
            border-radius: 10px;
            border: 2px solid var(--border);
        }

        .picker-value-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--surface);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            transition: background 0.15s;
        }
        .picker-value-row:hover { background: var(--surface-hover); }

        .picker-value-row .label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            font-weight: 600;
        }
        .picker-value-row .value {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.75rem;
        }

        .picker-btn-row {
            display: flex;
            gap: 0.5rem;
            width: 100%;
        }

        .picker-btn {
            flex: 1;
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }
        .picker-btn:hover { background: var(--surface-hover); color: var(--text); }
        .picker-btn.primary {
            background: rgba(72,219,251,0.15);
            border-color: rgba(72,219,251,0.3);
            color: #48dbfb;
        }
        .picker-btn.primary:hover { background: rgba(72,219,251,0.25); }

        /* ── Save Panel ── */
        .save-panel {
            position: fixed;
            top: 52px;
            right: 0;
            width: 280px;
            max-height: calc(100vh - 52px);
            background: var(--bg-alt);
            border-left: 1px solid var(--border);
            z-index: 150;
            display: none;
            flex-direction: column;
            overflow-y: auto;
            transition: background 0.4s ease;
        }
        .save-panel.active { display: flex; }

        .save-panel-header {
            padding: 0.8rem 1rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .save-input-row {
            display: flex;
            gap: 0.4rem;
            padding: 0.6rem 0.8rem;
            border-bottom: 1px solid var(--border);
        }

        .save-input-row input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            font-size: 0.75rem;
            outline: none;
        }
        .save-input-row input:focus { border-color: var(--border-hover); }

        .save-input-row button {
            padding: 0.4rem 0.7rem;
            border-radius: 6px;
            border: 1px solid rgba(72,219,251,0.3);
            background: rgba(72,219,251,0.15);
            color: #48dbfb;
            font-size: 0.72rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        .save-input-row button:hover { background: rgba(72,219,251,0.25); }

        .saved-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.8rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
            gap: 0.5rem;
        }
        .saved-item:hover { background: var(--surface-hover); }

        .saved-swatches {
            display: flex;
            gap: 2px;
            flex-shrink: 0;
        }
        .saved-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        .saved-name {
            font-size: 0.72rem;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .saved-delete {
            font-size: 0.7rem;
            color: var(--text-dim);
            cursor: pointer;
            padding: 0.2rem;
            border: none;
            background: none;
            transition: color 0.15s;
        }
        .saved-delete:hover { color: #ff4757; }

        .save-empty {
            padding: 1.5rem;
            text-align: center;
            font-size: 0.72rem;
            color: var(--text-dim);
        }

        /* ── Toast ── */
        .copy-toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--toast-bg);
            backdrop-filter: blur(20px);
            padding: 0.6rem 1.2rem;
            border-radius: 10px;
            font-size: 0.8rem;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            border: 1px solid var(--border);
            z-index: 300;
        }
        .copy-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        .glow-particle {
            position: fixed;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            pointer-events: none;
            animation: burst 0.7s ease-out forwards;
            z-index: 301;
        }

        @keyframes burst {
            from { opacity: 1; transform: translate(0, 0) scale(1); }
            to { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0); }
        }

        /* ── Paint canvas overlay ── */
        .paint-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            cursor: none;
            display: none;
        }
        .paint-overlay.active { display: block; }

        .paint-controls {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            display: none;
            gap: 0.6rem;
            align-items: center;
            background: rgba(15,15,26,0.92);
            backdrop-filter: blur(20px);
            padding: 0.5rem 1rem;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        .paint-controls.active { display: flex; }

        .paint-controls label {
            font-size: 0.7rem;
            color: #888;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .paint-controls input[type="range"] { width: 70px; accent-color: #ff6b6b; }
        .paint-controls .range-val { font-family: 'SF Mono', monospace; font-size: 0.7rem; color: #aaa; width: 26px; }

        .paint-controls .btn {
            padding: 0.3rem 0.7rem;
            font-size: 0.68rem;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: #999;
            cursor: pointer;
            transition: all 0.2s;
        }
        .paint-controls .btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .paint-controls .btn.active-mode { background: rgba(255,255,255,0.15); color: #fff; border-color: rgba(255,255,255,0.3); }
        .paint-controls .sep { width: 1px; height: 18px; background: rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-logo">Palette Generator</div>
        <select id="harmonySelect">
            <option value="complementary">Complementary</option>
            <option value="analogous">Analogous</option>
            <option value="triadic">Triadic</option>
            <option value="split">Split-Complementary</option>
            <option value="monochromatic">Monochromatic</option>
        </select>
        <button class="toolbar-btn" id="modeBtn" onclick="toggleMode()">Free Pick</button>
        <div class="toolbar-sep"></div>
        <button class="toolbar-btn" id="contrastBtn" onclick="toggleContrast()">Contrast</button>
        <button class="toolbar-btn" id="saveBtn" onclick="toggleSavePanel()">Saved</button>
        <div class="toolbar-sep"></div>
        <button class="toolbar-btn paint-btn" id="paintBtn" onclick="togglePaint()">Try Your Color</button>
        <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle theme"></button>
        <span class="toolbar-hint"><kbd>Space</kbd> shuffle</span>
    </div>

    <!-- Main Strips -->
    <div class="strips-container" id="stripsContainer"></div>

    <!-- Save Panel -->
    <div class="save-panel" id="savePanel">
        <div class="save-panel-header">
            <span>Saved Palettes</span>
            <button class="saved-delete" onclick="toggleSavePanel()" title="Close">&#10005;</button>
        </div>
        <div class="save-input-row">
            <input type="text" id="saveName" placeholder="Palette name..." maxlength="30">
            <button onclick="savePalette()">Save</button>
        </div>
        <div id="savedList"></div>
    </div>

    <!-- Picker Modal -->
    <div class="picker-backdrop" id="pickerBackdrop" onclick="closePicker()"></div>
    <div class="picker-modal" id="pickerModal">
        <div class="picker-modal-title">Edit Color</div>
        <div class="picker-layout">
            <div class="hue-ring-container">
                <canvas class="hue-ring" id="hueRing" width="220" height="220"></canvas>
                <div class="hue-indicator" id="hueIndicator"></div>
                <canvas class="sl-square" id="slSquare" width="90" height="90"></canvas>
                <div class="sl-indicator" id="slIndicator"></div>
            </div>
            <div class="picker-info">
                <div class="picker-preview" id="pickerPreview"></div>
                <div class="picker-value-row" onclick="copyPickerValue('hex')">
                    <span class="label">HEX</span>
                    <span class="value" id="pickerHex">#FF6B6B</span>
                </div>
                <div class="picker-value-row" onclick="copyPickerValue('rgb')">
                    <span class="label">RGB</span>
                    <span class="value" id="pickerRgb">rgb(255,107,107)</span>
                </div>
                <div class="picker-value-row" onclick="copyPickerValue('hsl')">
                    <span class="label">HSL</span>
                    <span class="value" id="pickerHsl">hsl(0,100%,71%)</span>
                </div>
                <div class="picker-btn-row">
                    <button class="picker-btn" onclick="pickerRandom()">Random</button>
                    <button class="picker-btn primary" onclick="closePicker()">Done</button>
                </div>
            </div>
        </div>
    </div>

    <div class="copy-toast" id="copyToast">Copied!</div>

    <!-- Paint mode -->
    <canvas class="paint-overlay" id="paintCanvas"></canvas>
    <div class="paint-controls" id="paintControls">
        <button class="btn active-mode" data-fx="glow" onclick="setFx('glow')">Glow</button>
        <button class="btn" data-fx="ribbon" onclick="setFx('ribbon')">Ribbon</button>
        <button class="btn" data-fx="metaball" onclick="setFx('metaball')">Metaball</button>
        <button class="btn" data-fx="particles" onclick="setFx('particles')">Particles</button>
        <div class="sep"></div>
        <label>Color
            <input type="color" id="paintColor" value="#ff6b6b" style="width:28px;height:22px;border:none;background:none;cursor:pointer;">
        </label>
        <label>Size
            <input type="range" id="brushSize" min="3" max="60" value="20">
            <span class="range-val" id="brushSizeVal">20</span>
        </label>
        <label>Fade
            <input type="range" id="fadeSpeed" min="1" max="20" value="8">
            <span class="range-val" id="fadeSpeedVal">8</span>
        </label>
        <div class="sep"></div>
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="togglePaint()">Exit</button>
    </div>

    <script>
        // ── State ──
        let palette = [];
        let mode = 'harmony';
        let editingIndex = -1;
        let paintMode = false;
        let dragSourceIndex = -1;
        let showContrast = false;
        let currentTheme = localStorage.getItem('palette-theme') || 'dark';

        let pickerH = 0, pickerS = 100, pickerL = 50;
        let draggingHue = false, draggingSL = false;

        const RING_SIZE = 220;
        const RING_CENTER = RING_SIZE / 2;
        const RING_OUTER = RING_CENTER;
        const RING_INNER = 68;
        const SL_SIZE = 90;
        const RING_MID = (RING_OUTER + RING_INNER) / 2;

        const stripsContainer = document.getElementById('stripsContainer');
        const harmonySelect = document.getElementById('harmonySelect');

        // ── Theme ──
        function applyTheme(theme) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('themeToggle').textContent = theme === 'dark' ? '\u2600' : '\u263D';
            localStorage.setItem('palette-theme', theme);
        }

        function toggleTheme() {
            applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
        }

        applyTheme(currentTheme);

        // ── Contrast Checker (WCAG) ──
        function luminance(r, g, b) {
            const [rs, gs, bs] = [r, g, b].map(c => {
                c /= 255;
                return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
        }

        function contrastRatio(rgb1, rgb2) {
            const l1 = luminance(rgb1[0], rgb1[1], rgb1[2]);
            const l2 = luminance(rgb2[0], rgb2[1], rgb2[2]);
            const lighter = Math.max(l1, l2);
            const darker = Math.min(l1, l2);
            return (lighter + 0.05) / (darker + 0.05);
        }

        function toggleContrast() {
            showContrast = !showContrast;
            document.getElementById('contrastBtn').classList.toggle('active', showContrast);
            renderPalette();
        }

        // ── localStorage Save/Load ──
        function getSavedPalettes() {
            try { return JSON.parse(localStorage.getItem('saved-palettes') || '[]'); }
            catch { return []; }
        }

        function setSavedPalettes(list) {
            localStorage.setItem('saved-palettes', JSON.stringify(list));
        }

        function savePalette() {
            const input = document.getElementById('saveName');
            const name = input.value.trim() || ('Palette ' + (getSavedPalettes().length + 1));
            const saved = getSavedPalettes();
            saved.unshift({ name, colors: palette.map(c => ({ h: c.h, s: c.s, l: c.l })), date: Date.now() });
            if (saved.length > 50) saved.length = 50;
            setSavedPalettes(saved);
            input.value = '';
            renderSavedList();
            showToast('Palette saved!');
        }

        function loadPalette(index) {
            const saved = getSavedPalettes();
            if (!saved[index]) return;
            palette = saved[index].colors.map(c => ({ ...c, locked: false }));
            renderPalette();
            showToast('Palette loaded!');
        }

        function deleteSavedPalette(index, e) {
            e.stopPropagation();
            const saved = getSavedPalettes();
            saved.splice(index, 1);
            setSavedPalettes(saved);
            renderSavedList();
        }

        function renderSavedList() {
            const list = document.getElementById('savedList');
            const saved = getSavedPalettes();
            if (saved.length === 0) {
                list.innerHTML = '<div class="save-empty">No saved palettes yet</div>';
                return;
            }
            list.innerHTML = '';
            saved.forEach((item, i) => {
                const row = document.createElement('div');
                row.className = 'saved-item';
                row.onclick = () => loadPalette(i);

                const swatches = document.createElement('div');
                swatches.className = 'saved-swatches';
                item.colors.forEach(c => {
                    const sw = document.createElement('div');
                    sw.className = 'saved-swatch';
                    sw.style.backgroundColor = `hsl(${c.h}, ${clamp(c.s,0,100)}%, ${clamp(c.l,0,100)}%)`;
                    swatches.appendChild(sw);
                });

                const name = document.createElement('span');
                name.className = 'saved-name';
                name.textContent = item.name;

                const del = document.createElement('button');
                del.className = 'saved-delete';
                del.innerHTML = '&#10005;';
                del.title = 'Delete';
                del.onclick = (e) => deleteSavedPalette(i, e);

                row.appendChild(swatches);
                row.appendChild(name);
                row.appendChild(del);
                list.appendChild(row);
            });
        }

        function toggleSavePanel() {
            const panel = document.getElementById('savePanel');
            panel.classList.toggle('active');
            document.getElementById('saveBtn').classList.toggle('active', panel.classList.contains('active'));
            if (panel.classList.contains('active')) renderSavedList();
        }

        // ── Init palette ──
        function initPalette() {
            const baseH = Math.random() * 360;
            const baseS = 55 + Math.random() * 45;
            const baseL = 35 + Math.random() * 35;
            palette = getHarmonyColors(harmonySelect.value, baseH, baseS, baseL).map(c => ({
                h: c.h, s: c.s, l: c.l, locked: false
            }));
            renderPalette();
        }

        // ── Harmony generation ──
        function getHarmonyColors(type, h, s, l) {
            switch (type) {
                case 'complementary':
                    return [
                        { h, s, l },
                        { h, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h: (h + 180) % 360, s, l },
                        { h: (h + 180) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h, s: s * 0.3, l: 18 },
                    ];
                case 'analogous':
                    return [
                        { h: (h - 30 + 360) % 360, s, l },
                        { h: (h - 15 + 360) % 360, s, l },
                        { h, s, l },
                        { h: (h + 15) % 360, s, l },
                        { h: (h + 30) % 360, s, l },
                    ];
                case 'triadic':
                    return [
                        { h, s, l },
                        { h: (h + 120) % 360, s, l },
                        { h: (h + 240) % 360, s, l },
                        { h: (h + 120) % 360, s: s * 0.5, l: Math.min(l + 22, 92) },
                        { h: (h + 240) % 360, s: s * 0.5, l: Math.min(l + 22, 92) },
                    ];
                case 'split':
                    return [
                        { h, s, l },
                        { h: (h + 150) % 360, s, l },
                        { h: (h + 210) % 360, s, l },
                        { h: (h + 150) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h: (h + 210) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                    ];
                case 'monochromatic':
                    return [
                        { h, s, l: 12 },
                        { h, s, l: 28 },
                        { h, s, l },
                        { h, s, l: 68 },
                        { h, s: s * 0.5, l: 85 },
                    ];
            }
        }

        // ── Render ──
        function renderPalette() {
            stripsContainer.innerHTML = '';

            palette.forEach((c, i) => {
                const cs = clamp(c.s, 0, 100);
                const cl = clamp(c.l, 0, 100);
                const rgb = hslToRgb(c.h, cs, cl);
                const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                const textColor = cl > 55 ? 'rgba(0,0,0,0.7)' : 'rgba(255,255,255,0.85)';

                const strip = document.createElement('div');
                strip.className = 'color-strip';
                strip.style.backgroundColor = `hsl(${Math.round(c.h)}, ${Math.round(cs)}%, ${Math.round(cl)}%)`;

                const content = document.createElement('div');
                content.className = 'strip-content';

                const actions = document.createElement('div');
                actions.className = 'strip-actions';

                const dragBtn = document.createElement('button');
                dragBtn.className = 'strip-drag';
                dragBtn.innerHTML = '&#8942;&#8942;';
                dragBtn.style.color = textColor;
                dragBtn.title = 'Drag to reorder';
                dragBtn.draggable = true;
                dragBtn.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    dragSourceIndex = i;
                    strip.classList.add('dragging');
                });
                strip.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const rect = strip.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                    if (e.clientX < midX) strip.classList.add('drag-over-left');
                    else strip.classList.add('drag-over-right');
                });
                strip.addEventListener('dragleave', () => {
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                });
                strip.addEventListener('drop', (e) => {
                    e.preventDefault();
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                    if (dragSourceIndex === -1) return;
                    const rect = strip.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    let targetIndex = e.clientX < midX ? i : i + 1;
                    if (dragSourceIndex < targetIndex) targetIndex--;
                    if (targetIndex !== dragSourceIndex) {
                        const [moved] = palette.splice(dragSourceIndex, 1);
                        palette.splice(targetIndex, 0, moved);
                    }
                    dragSourceIndex = -1;
                    renderPalette();
                });
                strip.addEventListener('dragend', () => {
                    strip.classList.remove('dragging');
                    dragSourceIndex = -1;
                });

                const lockBtn = document.createElement('button');
                lockBtn.className = 'strip-action' + (c.locked ? ' locked' : '');
                lockBtn.innerHTML = c.locked ? '&#128274;' : '&#128275;';
                lockBtn.style.color = textColor;
                lockBtn.title = c.locked ? 'Unlock' : 'Lock';
                lockBtn.onclick = (e) => { e.stopPropagation(); toggleLock(i); };

                const editBtn = document.createElement('button');
                editBtn.className = 'strip-action';
                editBtn.innerHTML = '&#9998;';
                editBtn.style.color = textColor;
                editBtn.title = 'Edit color';
                editBtn.onclick = (e) => { e.stopPropagation(); openPicker(i); };

                const removeBtn = document.createElement('button');
                removeBtn.className = 'strip-action';
                removeBtn.innerHTML = '&#10005;';
                removeBtn.style.color = textColor;
                removeBtn.title = 'Remove';
                if (palette.length <= 2) { removeBtn.style.opacity = '0.3'; removeBtn.style.pointerEvents = 'none'; }
                removeBtn.onclick = (e) => { e.stopPropagation(); removeColor(i); };

                actions.appendChild(dragBtn);
                actions.appendChild(lockBtn);
                actions.appendChild(editBtn);
                actions.appendChild(removeBtn);

                const hexEl = document.createElement('div');
                hexEl.className = 'strip-hex';
                hexEl.style.color = textColor;
                hexEl.textContent = hex;
                hexEl.title = 'Click to copy';
                hexEl.onclick = (e) => { e.stopPropagation(); copyHex(hex, hexEl); };

                content.appendChild(actions);
                content.appendChild(hexEl);

                // Contrast badge
                if (showContrast && i < palette.length - 1) {
                    const nextC = palette[i + 1];
                    const nextRgb = hslToRgb(nextC.h, clamp(nextC.s,0,100), clamp(nextC.l,0,100));
                    const ratio = contrastRatio(rgb, nextRgb);
                    const badge = document.createElement('div');
                    badge.className = 'strip-contrast ' + (ratio >= 4.5 ? 'contrast-pass' : 'contrast-fail');
                    badge.textContent = ratio.toFixed(1) + ':1 ' + (ratio >= 7 ? 'AAA' : ratio >= 4.5 ? 'AA' : 'Fail');
                    badge.title = 'Contrast with next color';
                    content.appendChild(badge);
                }

                strip.appendChild(content);
                stripsContainer.appendChild(strip);
            });

            positionAddButtons();
        }

        function positionAddButtons() {
            stripsContainer.querySelectorAll('.add-btn').forEach(b => b.remove());
            if (palette.length >= 10) return;
            const strips = stripsContainer.querySelectorAll('.color-strip');
            if (strips.length === 0) return;

            const firstBtn = makeAddBtn(0);
            firstBtn.style.left = '8px';
            firstBtn.style.transform = 'translate(0, -50%)';
            stripsContainer.appendChild(firstBtn);

            strips.forEach((strip, i) => {
                if (i < strips.length - 1) {
                    const btn = makeAddBtn(i + 1);
                    const rect = strip.getBoundingClientRect();
                    const containerRect = stripsContainer.getBoundingClientRect();
                    btn.style.left = (rect.right - containerRect.left) + 'px';
                    stripsContainer.appendChild(btn);
                }
            });

            const lastBtn = makeAddBtn(palette.length);
            lastBtn.style.right = '8px';
            lastBtn.style.left = 'auto';
            lastBtn.style.transform = 'translate(0, -50%)';
            stripsContainer.appendChild(lastBtn);
        }

        function makeAddBtn(index) {
            const btn = document.createElement('button');
            btn.className = 'add-btn';
            btn.innerHTML = '+';
            btn.title = 'Add color';
            btn.onclick = () => addColor(index);
            return btn;
        }

        // ── Palette actions ──
        function toggleLock(i) {
            palette[i].locked = !palette[i].locked;
            renderPalette();
        }

        function removeColor(i) {
            if (palette.length <= 2) return;
            palette.splice(i, 1);
            renderPalette();
        }

        function addColor(i) {
            if (palette.length >= 10) return;
            palette.splice(i, 0, { h: Math.random() * 360, s: 55 + Math.random() * 45, l: 35 + Math.random() * 35, locked: false });
            renderPalette();
        }

        // ── Mode toggle ──
        function toggleMode() {
            const btn = document.getElementById('modeBtn');
            if (mode === 'harmony') {
                mode = 'free';
                btn.textContent = 'Harmony';
                btn.classList.add('active');
                harmonySelect.disabled = true;
                harmonySelect.style.opacity = '0.4';
            } else {
                mode = 'harmony';
                btn.textContent = 'Free Pick';
                btn.classList.remove('active');
                harmonySelect.disabled = false;
                harmonySelect.style.opacity = '1';
                regenerateHarmony();
            }
        }

        function regenerateHarmony() {
            const base = palette.find(c => !c.locked) || palette[0];
            const colors = getHarmonyColors(harmonySelect.value, base.h, base.s, base.l);
            for (let i = 0; i < palette.length && i < colors.length; i++) {
                if (!palette[i].locked) {
                    palette[i].h = colors[i].h;
                    palette[i].s = colors[i].s;
                    palette[i].l = colors[i].l;
                }
            }
            renderPalette();
        }

        harmonySelect.addEventListener('change', () => {
            if (mode === 'harmony') regenerateHarmony();
        });

        // ── Spacebar ──
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !paintMode && document.activeElement === document.body) {
                e.preventDefault();
                randomizePalette();
            }
            if (e.code === 'Escape') {
                if (paintMode) togglePaint();
                else if (editingIndex >= 0) closePicker();
            }
        });

        function randomizePalette() {
            if (mode === 'harmony') {
                const baseH = Math.random() * 360;
                const baseS = 55 + Math.random() * 45;
                const baseL = 35 + Math.random() * 35;
                const colors = getHarmonyColors(harmonySelect.value, baseH, baseS, baseL);
                for (let i = 0; i < palette.length; i++) {
                    if (!palette[i].locked && i < colors.length) {
                        palette[i].h = colors[i].h;
                        palette[i].s = colors[i].s;
                        palette[i].l = colors[i].l;
                    }
                }
            } else {
                palette.forEach(c => {
                    if (!c.locked) {
                        c.h = Math.random() * 360;
                        c.s = 55 + Math.random() * 45;
                        c.l = 35 + Math.random() * 35;
                    }
                });
            }
            renderPalette();
        }

        // ── Picker Modal ──
        const hueRing = document.getElementById('hueRing');
        const hueIndicator = document.getElementById('hueIndicator');
        const slSquare = document.getElementById('slSquare');
        const slIndicator = document.getElementById('slIndicator');

        function openPicker(index) {
            editingIndex = index;
            const c = palette[index];
            pickerH = c.h; pickerS = c.s; pickerL = c.l;
            document.getElementById('pickerBackdrop').classList.add('active');
            document.getElementById('pickerModal').classList.add('active');
            drawHueRing();
            drawSLSquare();
            updatePickerDisplay();
        }

        function closePicker() {
            document.getElementById('pickerBackdrop').classList.remove('active');
            document.getElementById('pickerModal').classList.remove('active');
            editingIndex = -1;
        }

        function applyPickerToStrip() {
            if (editingIndex < 0 || editingIndex >= palette.length) return;
            palette[editingIndex].h = pickerH;
            palette[editingIndex].s = pickerS;
            palette[editingIndex].l = pickerL;
            if (mode === 'harmony') {
                const colors = getHarmonyColors(harmonySelect.value, pickerH, pickerS, pickerL);
                for (let i = 0; i < palette.length && i < colors.length; i++) {
                    if (!palette[i].locked && i !== editingIndex) {
                        palette[i].h = colors[i].h;
                        palette[i].s = colors[i].s;
                        palette[i].l = colors[i].l;
                    }
                }
            }
            renderPalette();
        }

        function pickerRandom() {
            pickerH = Math.random() * 360;
            pickerS = 55 + Math.random() * 45;
            pickerL = 35 + Math.random() * 35;
            drawSLSquare();
            updatePickerDisplay();
            applyPickerToStrip();
        }

        function drawHueRing() {
            const ctx = hueRing.getContext('2d');
            ctx.clearRect(0, 0, RING_SIZE, RING_SIZE);
            for (let angle = 0; angle < 360; angle += 0.5) {
                const rad = (angle - 90) * Math.PI / 180;
                const rad2 = (angle - 89.5) * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(RING_CENTER + RING_INNER * Math.cos(rad), RING_CENTER + RING_INNER * Math.sin(rad));
                ctx.lineTo(RING_CENTER + RING_OUTER * Math.cos(rad), RING_CENTER + RING_OUTER * Math.sin(rad));
                ctx.lineTo(RING_CENTER + RING_OUTER * Math.cos(rad2), RING_CENTER + RING_OUTER * Math.sin(rad2));
                ctx.lineTo(RING_CENTER + RING_INNER * Math.cos(rad2), RING_CENTER + RING_INNER * Math.sin(rad2));
                ctx.closePath();
                ctx.fillStyle = `hsl(${angle}, 100%, 50%)`;
                ctx.fill();
            }
        }

        function drawSLSquare() {
            const ctx = slSquare.getContext('2d');
            const imageData = ctx.createImageData(SL_SIZE, SL_SIZE);
            for (let y = 0; y < SL_SIZE; y++) {
                for (let x = 0; x < SL_SIZE; x++) {
                    const s = (x / SL_SIZE) * 100;
                    const l = 100 - (y / SL_SIZE) * 100;
                    const rgb = hslToRgb(pickerH, s, l);
                    const i = (y * SL_SIZE + x) * 4;
                    imageData.data[i] = rgb[0];
                    imageData.data[i + 1] = rgb[1];
                    imageData.data[i + 2] = rgb[2];
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updatePickerDisplay() {
            const rgb = hslToRgb(pickerH, pickerS, pickerL);
            const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
            document.getElementById('pickerPreview').style.backgroundColor = `hsl(${pickerH}, ${pickerS}%, ${pickerL}%)`;
            document.getElementById('pickerHex').textContent = hex;
            document.getElementById('pickerRgb').textContent = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            document.getElementById('pickerHsl').textContent = `hsl(${Math.round(pickerH)}, ${Math.round(pickerS)}%, ${Math.round(pickerL)}%)`;
            const rad = (pickerH - 90) * Math.PI / 180;
            hueIndicator.style.left = (RING_CENTER + RING_MID * Math.cos(rad)) + 'px';
            hueIndicator.style.top = (RING_CENTER + RING_MID * Math.sin(rad)) + 'px';
            hueIndicator.style.backgroundColor = `hsl(${pickerH}, 100%, 50%)`;
            const slRect = slSquare.getBoundingClientRect();
            const containerRect = slSquare.parentElement.getBoundingClientRect();
            slIndicator.style.left = (slRect.left - containerRect.left + (pickerS / 100) * SL_SIZE) + 'px';
            slIndicator.style.top = (slRect.top - containerRect.top + ((100 - pickerL) / 100) * SL_SIZE) + 'px';
            applyPickerToStrip();
        }

        hueRing.addEventListener('mousedown', (e) => { draggingHue = true; pickHue(e); });
        slSquare.addEventListener('mousedown', (e) => { draggingSL = true; pickSL(e); });
        document.addEventListener('mousemove', (e) => {
            if (draggingHue) pickHue(e);
            if (draggingSL) pickSL(e);
        });
        document.addEventListener('mouseup', () => { draggingHue = false; draggingSL = false; });

        function pickHue(e) {
            const rect = hueRing.getBoundingClientRect();
            pickerH = (Math.atan2(e.clientY - rect.top - RING_CENTER, e.clientX - rect.left - RING_CENTER) * 180 / Math.PI + 90 + 360) % 360;
            drawSLSquare();
            updatePickerDisplay();
        }

        function pickSL(e) {
            const rect = slSquare.getBoundingClientRect();
            pickerS = (clamp(e.clientX - rect.left, 0, SL_SIZE) / SL_SIZE) * 100;
            pickerL = 100 - (clamp(e.clientY - rect.top, 0, SL_SIZE) / SL_SIZE) * 100;
            updatePickerDisplay();
        }

        // ── Copy ──
        function copyHex(hex, el) {
            navigator.clipboard.writeText(hex);
            showParticles(el);
            showToast(`Copied ${hex}`);
        }

        function copyPickerValue(type) {
            const el = document.getElementById('picker' + type.charAt(0).toUpperCase() + type.slice(1));
            navigator.clipboard.writeText(el.textContent);
            showToast(`Copied ${el.textContent}`);
        }

        function showParticles(el) {
            const rect = el.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const rgb = hslToRgb(pickerH, pickerS, pickerL);
            for (let i = 0; i < 8; i++) {
                const p = document.createElement('div');
                p.className = 'glow-particle';
                const angle = (i / 8) * Math.PI * 2;
                const dist = 35 + Math.random() * 25;
                p.style.left = cx + 'px';
                p.style.top = cy + 'px';
                p.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--dy', Math.sin(angle) * dist + 'px');
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 700);
            }
        }

        function showToast(text) {
            const toast = document.getElementById('copyToast');
            toast.textContent = text;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 1400);
        }

        // ── Paint mode ──
        const paintCanvas = document.getElementById('paintCanvas');
        const paintCtx = paintCanvas.getContext('2d');
        const paintControls = document.getElementById('paintControls');
        const paintBtn = document.getElementById('paintBtn');
        const brushSizeInput = document.getElementById('brushSize');
        const fadeSpeedInput = document.getElementById('fadeSpeed');
        const paintColorInput = document.getElementById('paintColor');
        let animFrame;
        let currentFx = 'glow';
        let mouseX = 0, mouseY = 0;
        let paintHue = 0, paintSat = 100, paintLight = 50;

        const blobSprite = document.createElement('canvas');
        blobSprite.width = blobSprite.height = 64;
        const bctx = blobSprite.getContext('2d');
        const bg = bctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        bg.addColorStop(0, 'rgba(255,255,255,1)');
        bg.addColorStop(0.4, 'rgba(255,255,255,0.6)');
        bg.addColorStop(1, 'rgba(255,255,255,0)');
        bctx.fillStyle = bg;
        bctx.fillRect(0, 0, 64, 64);

        function syncPaintColor() {
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            paintColorInput.value = rgbToHex(rgb[0], rgb[1], rgb[2]);
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h * 360, s * 100, l * 100];
        }

        paintColorInput.addEventListener('input', (e) => {
            const hex = e.target.value;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            [paintHue, paintSat, paintLight] = rgbToHsl(r, g, b);
        });

        const CHAIN_LEN = 50;
        const chain = [];
        for (let i = 0; i < CHAIN_LEN; i++) chain.push({ x: 0, y: 0 });

        function updateChain() {
            chain[0].x += (mouseX - chain[0].x) * 0.35;
            chain[0].y += (mouseY - chain[0].y) * 0.35;
            for (let i = 1; i < CHAIN_LEN; i++) {
                const ease = 0.32 * (1 - (i / CHAIN_LEN) * 0.6);
                chain[i].x += (chain[i - 1].x - chain[i].x) * ease;
                chain[i].y += (chain[i - 1].y - chain[i].y) * ease;
            }
        }

        const particles = [];
        const MAX_PARTICLES = 400;

        function spawnParticle(x, y) {
            if (particles.length >= MAX_PARTICLES) return;
            const rgb = hslToRgb(paintHue + (Math.random() - 0.5) * 25, paintSat, paintLight);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.3 + Math.random() * 1.5;
            particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 0.5, r: rgb[0], g: rgb[1], b: rgb[2], life: 1, decay: 0.008 + Math.random() * 0.015, size: 3 + Math.random() * (parseInt(brushSizeInput.value) * 0.4) });
        }

        const streaks = [];
        let streakTimer = 0;

        function spawnStreak() {
            const hueShift = (Math.random() - 0.5) * 50;
            const srgb = hslToRgb((paintHue + hueShift + 360) % 360, paintSat, paintLight);
            const w = paintCanvas.width, h = paintCanvas.height;
            const side = Math.floor(Math.random() * 4);
            let sx, sy, ang;
            if (side === 0) { sx = -10; sy = Math.random() * h; ang = (Math.random() - 0.5) * 0.5; }
            else if (side === 1) { sx = w + 10; sy = Math.random() * h; ang = Math.PI + (Math.random() - 0.5) * 0.5; }
            else if (side === 2) { sx = Math.random() * w; sy = -10; ang = Math.PI / 2 + (Math.random() - 0.5) * 0.5; }
            else { sx = Math.random() * w; sy = h + 10; ang = -Math.PI / 2 + (Math.random() - 0.5) * 0.5; }
            streaks.push({ x: sx, y: sy, vx: Math.cos(ang) * (2 + Math.random() * 3), vy: Math.sin(ang) * (2 + Math.random() * 3), r: srgb[0], g: srgb[1], b: srgb[2], size: 2 + Math.random() * 4, trail: [], maxTrail: 35 + Math.floor(Math.random() * 50), life: 200 + Math.random() * 150, age: 0 });
        }

        function drawStreaks(ctx) {
            streakTimer++;
            if (streakTimer > 40 + Math.random() * 60) { spawnStreak(); streakTimer = 0; }
            ctx.lineCap = 'round';
            for (let i = streaks.length - 1; i >= 0; i--) {
                const s = streaks[i];
                s.x += s.vx; s.y += s.vy; s.age++;
                s.trail.push({ x: s.x, y: s.y });
                if (s.trail.length > s.maxTrail) s.trail.shift();
                if (s.age > s.life) { streaks.splice(i, 1); continue; }
                const fadeIn = Math.min(1, s.age / 20);
                const fadeOut = s.age > s.life - 30 ? Math.max(0, 1 - (s.age - (s.life - 30)) / 30) : 1;
                const ba = Math.min(fadeIn, fadeOut);
                if (s.trail.length < 3) continue;
                for (const [lw, alpha] of [[s.size * 5, ba * 0.06], [s.size * 1.5, ba * 0.25]]) {
                    ctx.beginPath();
                    ctx.moveTo(s.trail[0].x, s.trail[0].y);
                    for (let j = 1; j < s.trail.length - 1; j++) {
                        ctx.quadraticCurveTo(s.trail[j].x, s.trail[j].y, (s.trail[j].x + s.trail[j + 1].x) / 2, (s.trail[j].y + s.trail[j + 1].y) / 2);
                    }
                    ctx.lineWidth = lw;
                    ctx.strokeStyle = `rgba(${s.r}, ${s.g}, ${s.b}, ${alpha})`;
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(s.trail[0].x, s.trail[0].y);
                for (let j = 1; j < s.trail.length - 1; j++) {
                    ctx.quadraticCurveTo(s.trail[j].x, s.trail[j].y, (s.trail[j].x + s.trail[j + 1].x) / 2, (s.trail[j].y + s.trail[j + 1].y) / 2);
                }
                ctx.lineWidth = s.size * 0.5;
                ctx.strokeStyle = `rgba(${Math.min(255, s.r + 100)}, ${Math.min(255, s.g + 100)}, ${Math.min(255, s.b + 100)}, ${ba * 0.5})`;
                ctx.stroke();
                const headR = s.size * 3.5;
                const headGrad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, headR);
                headGrad.addColorStop(0, `rgba(${Math.min(255, s.r + 80)}, ${Math.min(255, s.g + 80)}, ${Math.min(255, s.b + 80)}, ${ba * 0.5})`);
                headGrad.addColorStop(0.3, `rgba(${s.r}, ${s.g}, ${s.b}, ${ba * 0.15})`);
                headGrad.addColorStop(1, `rgba(${s.r}, ${s.g}, ${s.b}, 0)`);
                ctx.beginPath();
                ctx.arc(s.x, s.y, headR, 0, Math.PI * 2);
                ctx.fillStyle = headGrad;
                ctx.fill();
            }
        }

        function drawGlow(ctx) {
            const size = parseInt(brushSizeInput.value);
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            const [r, g, b] = rgb;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            for (const [lw, alpha] of [[size * 3, 0.08], [size * 1.4, 0.2]]) {
                ctx.beginPath(); ctx.moveTo(chain[0].x, chain[0].y);
                for (let i = 1; i < CHAIN_LEN - 1; i++) ctx.quadraticCurveTo(chain[i].x, chain[i].y, (chain[i].x + chain[i + 1].x) / 2, (chain[i].y + chain[i + 1].y) / 2);
                ctx.lineWidth = lw; ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`; ctx.stroke();
            }
            for (let i = 1; i < CHAIN_LEN - 1; i++) {
                const t = 1 - i / CHAIN_LEN; const w = size * t;
                if (w < 0.5) continue;
                ctx.beginPath(); ctx.moveTo(chain[i - 1].x, chain[i - 1].y);
                ctx.quadraticCurveTo(chain[i].x, chain[i].y, (chain[i].x + chain[i + 1].x) / 2, (chain[i].y + chain[i + 1].y) / 2);
                ctx.lineWidth = w; ctx.strokeStyle = `rgba(${r},${g},${b},${t * 0.9})`; ctx.stroke();
            }
            const headR = size * 0.6;
            const headGrad = ctx.createRadialGradient(chain[0].x, chain[0].y, 0, chain[0].x, chain[0].y, headR);
            headGrad.addColorStop(0, `rgba(${Math.min(255,r+120)},${Math.min(255,g+120)},${Math.min(255,b+120)},0.95)`);
            headGrad.addColorStop(0.4, `rgba(${r},${g},${b},0.4)`);
            headGrad.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.beginPath(); ctx.arc(chain[0].x, chain[0].y, headR, 0, Math.PI * 2);
            ctx.fillStyle = headGrad; ctx.fill();
        }

        function drawRibbon(ctx) {
            const size = parseInt(brushSizeInput.value);
            const [r, g, b] = hslToRgb(paintHue, paintSat, paintLight);
            const path1 = [], path2 = [];
            for (let i = 0; i < CHAIN_LEN - 1; i++) {
                const t = 1 - i / CHAIN_LEN; const width = size * t * 1.2;
                const dx = chain[Math.min(i+1,CHAIN_LEN-1)].x - chain[i].x;
                const dy = chain[Math.min(i+1,CHAIN_LEN-1)].y - chain[i].y;
                const angle = Math.atan2(dy, dx);
                const wave = Math.sin(i * 0.12 + Date.now() * 0.002) * width * 0.25;
                const px = Math.cos(angle + Math.PI/2) * (width + wave);
                const py = Math.sin(angle + Math.PI/2) * (width + wave);
                path1.push({ x: chain[i].x + px, y: chain[i].y + py });
                path2.push({ x: chain[i].x - px, y: chain[i].y - py });
            }
            ctx.beginPath(); ctx.moveTo(path1[0].x, path1[0].y);
            for (let i = 1; i < path1.length - 1; i++) ctx.quadraticCurveTo(path1[i].x, path1[i].y, (path1[i].x+path1[i+1].x)/2, (path1[i].y+path1[i+1].y)/2);
            for (let i = path2.length-1; i > 0; i--) ctx.quadraticCurveTo(path2[i].x, path2[i].y, (path2[i].x+path2[i-1].x)/2, (path2[i].y+path2[i-1].y)/2);
            ctx.closePath();
            const grad = ctx.createLinearGradient(chain[0].x, chain[0].y, chain[CHAIN_LEN-1].x, chain[CHAIN_LEN-1].y);
            grad.addColorStop(0, `rgba(${r},${g},${b},0.6)`); grad.addColorStop(0.4, `rgba(${r},${g},${b},0.25)`); grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.fillStyle = grad; ctx.fill(); ctx.lineCap = 'round';
            for (const path of [path1, path2]) {
                ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length - 1; i++) ctx.quadraticCurveTo(path[i].x, path[i].y, (path[i].x+path[i+1].x)/2, (path[i].y+path[i+1].y)/2);
                ctx.lineWidth = 1.5; ctx.strokeStyle = `rgba(${Math.min(255,r+80)},${Math.min(255,g+80)},${Math.min(255,b+80)},0.25)`; ctx.stroke();
            }
        }

        const blobs = [];
        for (let i = 0; i < 8; i++) blobs.push({ x: 0, y: 0, baseSize: 12 + Math.random() * 18, orbitSpeed: 0.0008 + Math.random() * 0.0012, orbitOffset: (i / 8) * Math.PI * 2, lag: 0.04 + i * 0.012 });

        function drawMetaball(ctx) {
            const size = parseInt(brushSizeInput.value);
            const [r, g, b] = hslToRgb(paintHue, paintSat, paintLight);
            const now = Date.now();
            blobs.forEach(bl => {
                const angle = bl.orbitOffset + now * bl.orbitSpeed;
                const spread = size * 0.8 + size * 0.4 * Math.sin(now * 0.001 + bl.orbitOffset);
                bl.x += (mouseX + Math.cos(angle) * spread - bl.x) * bl.lag;
                bl.y += (mouseY + Math.sin(angle) * spread - bl.y) * bl.lag;
            });
            ctx.globalCompositeOperation = 'lighter';
            blobs.forEach(bl => {
                const radius = (bl.baseSize / 18) * size;
                const grad = ctx.createRadialGradient(bl.x, bl.y, 0, bl.x, bl.y, radius);
                grad.addColorStop(0, `rgba(${r},${g},${b},0.55)`); grad.addColorStop(0.45, `rgba(${r},${g},${b},0.2)`); grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
                ctx.beginPath(); ctx.arc(bl.x, bl.y, radius, 0, Math.PI * 2); ctx.fillStyle = grad; ctx.fill();
            });
            const mainR = size * 0.7;
            const mainGrad = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, mainR);
            mainGrad.addColorStop(0, `rgba(${Math.min(255,r+80)},${Math.min(255,g+80)},${Math.min(255,b+80)},0.85)`);
            mainGrad.addColorStop(0.4, `rgba(${r},${g},${b},0.3)`); mainGrad.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.beginPath(); ctx.arc(mouseX, mouseY, mainR, 0, Math.PI * 2); ctx.fillStyle = mainGrad; ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawParticles(ctx) {
            const size = parseInt(brushSizeInput.value);
            for (let i = 0; i < 3; i++) spawnParticle(mouseX + (Math.random()-0.5)*size, mouseY + (Math.random()-0.5)*size);
            ctx.globalCompositeOperation = 'lighter';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.015; p.vx *= 0.995; p.life -= p.decay;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.life * 0.7;
                const s = p.size * p.life;
                ctx.drawImage(blobSprite, p.x - s, p.y - s, s * 2, s * 2);
            }
            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'multiply';
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`; ctx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        brushSizeInput.addEventListener('input', () => { document.getElementById('brushSizeVal').textContent = brushSizeInput.value; });
        fadeSpeedInput.addEventListener('input', () => { document.getElementById('fadeSpeedVal').textContent = fadeSpeedInput.value; });

        function setFx(fx) {
            currentFx = fx;
            document.querySelectorAll('.paint-controls .btn[data-fx]').forEach(b => b.classList.toggle('active-mode', b.dataset.fx === fx));
            clearCanvas();
        }

        function togglePaint() {
            paintMode = !paintMode;
            paintCanvas.classList.toggle('active', paintMode);
            paintControls.classList.toggle('active', paintMode);
            paintBtn.classList.toggle('active', paintMode);
            if (paintMode) {
                if (palette.length > 0) { paintHue = palette[0].h; paintSat = palette[0].s; paintLight = palette[0].l; }
                syncPaintColor(); resizePaintCanvas(); clearCanvas();
                chain.forEach(p => { p.x = mouseX; p.y = mouseY; });
                blobs.forEach(b => { b.x = mouseX; b.y = mouseY; });
                animFrame = requestAnimationFrame(paintLoop);
            } else { cancelAnimationFrame(animFrame); }
        }

        function resizePaintCanvas() { paintCanvas.width = window.innerWidth; paintCanvas.height = window.innerHeight; }
        window.addEventListener('resize', () => { resizePaintCanvas(); renderPalette(); });
        resizePaintCanvas();
        paintCanvas.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });

        function getPaintBg() {
            const cs = getComputedStyle(document.documentElement);
            return cs.getPropertyValue('--paint-fade').trim();
        }

        function paintLoop() {
            const fadeBg = getPaintBg();
            if (currentFx === 'particles') {
                const fade = parseInt(fadeSpeedInput.value);
                paintCtx.fillStyle = `rgba(${fadeBg}, ${fade / 300})`;
                paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            } else {
                paintCtx.fillStyle = `rgb(${fadeBg})`;
                paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            }
            updateChain(); paintCtx.lineCap = 'round'; paintCtx.lineJoin = 'round';
            switch (currentFx) {
                case 'glow': drawGlow(paintCtx); break;
                case 'ribbon': drawRibbon(paintCtx); break;
                case 'metaball': drawMetaball(paintCtx); break;
                case 'particles': drawParticles(paintCtx); break;
            }
            drawStreaks(paintCtx);
            animFrame = requestAnimationFrame(paintLoop);
        }

        function clearCanvas() {
            const fadeBg = getPaintBg();
            paintCtx.fillStyle = `rgb(${fadeBg})`;
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            particles.length = 0; streaks.length = 0;
        }

        // ── Color math ──
        function hslToRgb(h, s, l) {
            s /= 100; l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = (n) => { const k = (n + h / 30) % 12; return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); };
            return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0').toUpperCase()).join('');
        }

        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

        // ── Init ──
        initPalette();
    </script>
</body>
</html>
