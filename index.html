<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Palette Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            height: 100vh;
            background: #0f0f1a;
            color: #eee;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ── Toolbar ── */
        .toolbar {
            height: 52px;
            min-height: 52px;
            background: rgba(15, 15, 26, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            padding: 0 1.2rem;
            gap: 0.8rem;
            z-index: 100;
        }

        .toolbar-logo {
            font-size: 1.1rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 300% 300%;
            animation: gradientShift 4s ease infinite;
            margin-right: auto;
            white-space: nowrap;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .toolbar-btn {
            padding: 0.35rem 0.8rem;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .toolbar-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .toolbar-btn.active { background: rgba(255,255,255,0.15); color: #fff; border-color: rgba(255,255,255,0.3); }

        .toolbar-btn.paint-btn {
            background: linear-gradient(135deg, rgba(255,107,107,0.2), rgba(72,219,251,0.2));
            border-color: rgba(255,255,255,0.2);
            color: #ccc;
        }
        .toolbar-btn.paint-btn:hover {
            background: linear-gradient(135deg, rgba(255,107,107,0.35), rgba(72,219,251,0.35));
            color: #fff;
        }
        .toolbar-btn.paint-btn.active {
            background: linear-gradient(135deg, rgba(255,107,107,0.5), rgba(72,219,251,0.5));
            border-color: rgba(255,255,255,0.4);
        }

        .toolbar select {
            padding: 0.35rem 0.5rem;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: #ccc;
            font-size: 0.75rem;
            cursor: pointer;
            outline: none;
        }
        .toolbar select option { background: #1a1a2e; color: #eee; }

        .toolbar-hint {
            font-size: 0.65rem;
            color: #555;
        }
        .toolbar-hint kbd {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 3px;
            padding: 0.1rem 0.35rem;
            font-family: inherit;
            font-size: 0.6rem;
        }

        .toolbar-sep {
            width: 1px;
            height: 24px;
            background: rgba(255,255,255,0.08);
        }

        /* ── Strips Container ── */
        .strips-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .color-strip {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: flex 0.3s ease;
            cursor: default;
            min-width: 0;
        }

        .strip-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.6rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .color-strip:hover .strip-content { opacity: 1; pointer-events: auto; }

        .strip-hex {
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            cursor: pointer;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            transition: background 0.15s ease;
        }
        .strip-hex:hover { background: rgba(0,0,0,0.15); }

        .strip-actions {
            display: flex;
            gap: 0.5rem;
        }

        .strip-action {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            background: rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            font-size: 1rem;
        }
        .strip-action:hover { background: rgba(0,0,0,0.35); transform: scale(1.1); }
        .strip-action.locked { background: rgba(255,255,255,0.2); }

        /* ── Drag Handle ── */
        .strip-drag {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            background: rgba(0,0,0,0.2);
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            font-size: 0.9rem;
            letter-spacing: 2px;
        }
        .strip-drag:hover { background: rgba(0,0,0,0.35); transform: scale(1.1); }
        .strip-drag:active { cursor: grabbing; }

        .color-strip.dragging {
            opacity: 0.4;
        }

        .color-strip.drag-over-left {
            box-shadow: inset 4px 0 0 0 rgba(255,255,255,0.6);
        }
        .color-strip.drag-over-right {
            box-shadow: inset -4px 0 0 0 rgba(255,255,255,0.6);
        }

        /* ── Add Color Buttons ── */
        .add-btn {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            background: rgba(15, 15, 26, 0.8);
            color: rgba(255,255,255,0.5);
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            transition: all 0.2s ease;
        }
        .strips-container:hover .add-btn { opacity: 1; }
        .add-btn:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
            border-color: rgba(255,255,255,0.4);
            transform: translate(-50%, -50%) scale(1.15);
        }

        /* ── Picker Modal ── */
        .picker-backdrop {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
        }
        .picker-backdrop.active { display: block; }

        .picker-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 1.5rem;
            z-index: 201;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }
        .picker-modal.active { display: flex; }

        .picker-modal-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #666;
        }

        .picker-layout {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .hue-ring-container {
            position: relative;
            width: 220px;
            height: 220px;
        }

        .hue-ring { border-radius: 50%; cursor: crosshair; }

        .hue-indicator {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .sl-square {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 4px;
            cursor: crosshair;
            border: 2px solid rgba(255,255,255,0.12);
        }

        .sl-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .picker-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 160px;
        }

        .picker-preview {
            width: 100%;
            height: 60px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .picker-value-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            transition: background 0.15s;
        }
        .picker-value-row:hover { background: rgba(255,255,255,0.1); }

        .picker-value-row .label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
            font-weight: 600;
        }
        .picker-value-row .value {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.75rem;
        }

        .picker-btn-row {
            display: flex;
            gap: 0.5rem;
            width: 100%;
        }

        .picker-btn {
            flex: 1;
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: #ccc;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }
        .picker-btn:hover { background: rgba(255,255,255,0.12); color: #fff; }
        .picker-btn.primary {
            background: rgba(72,219,251,0.15);
            border-color: rgba(72,219,251,0.3);
            color: #48dbfb;
        }
        .picker-btn.primary:hover { background: rgba(72,219,251,0.25); }

        /* ── Toast ── */
        .copy-toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: rgba(20,20,35,0.9);
            backdrop-filter: blur(20px);
            padding: 0.6rem 1.2rem;
            border-radius: 10px;
            font-size: 0.8rem;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.12);
            z-index: 300;
        }
        .copy-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        .glow-particle {
            position: fixed;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            pointer-events: none;
            animation: burst 0.7s ease-out forwards;
            z-index: 301;
        }

        @keyframes burst {
            from { opacity: 1; transform: translate(0, 0) scale(1); }
            to { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0); }
        }

        /* ── Paint canvas overlay ── */
        .paint-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            cursor: none;
            display: none;
        }
        .paint-overlay.active { display: block; }

        .paint-controls {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            display: none;
            gap: 0.6rem;
            align-items: center;
            background: rgba(15,15,26,0.92);
            backdrop-filter: blur(20px);
            padding: 0.5rem 1rem;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        .paint-controls.active { display: flex; }

        .paint-controls label {
            font-size: 0.7rem;
            color: #888;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .paint-controls input[type="range"] { width: 70px; accent-color: #ff6b6b; }
        .paint-controls .range-val { font-family: 'SF Mono', monospace; font-size: 0.7rem; color: #aaa; width: 26px; }

        .paint-controls .btn {
            padding: 0.3rem 0.7rem;
            font-size: 0.68rem;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.05);
            color: #999;
            cursor: pointer;
            transition: all 0.2s;
        }
        .paint-controls .btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .paint-controls .btn.active-mode { background: rgba(255,255,255,0.15); color: #fff; border-color: rgba(255,255,255,0.3); }
        .paint-controls .sep { width: 1px; height: 18px; background: rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-logo">Palette Generator</div>
        <select id="harmonySelect">
            <option value="complementary">Complementary</option>
            <option value="analogous">Analogous</option>
            <option value="triadic">Triadic</option>
            <option value="split">Split-Complementary</option>
            <option value="monochromatic">Monochromatic</option>
        </select>
        <button class="toolbar-btn" id="modeBtn" onclick="toggleMode()">Free Pick</button>
        <div class="toolbar-sep"></div>
        <button class="toolbar-btn paint-btn" id="paintBtn" onclick="togglePaint()">Try Your Color</button>
        <span class="toolbar-hint"><kbd>Space</kbd> shuffle</span>
    </div>

    <!-- Main Strips -->
    <div class="strips-container" id="stripsContainer"></div>

    <!-- Picker Modal -->
    <div class="picker-backdrop" id="pickerBackdrop" onclick="closePicker()"></div>
    <div class="picker-modal" id="pickerModal">
        <div class="picker-modal-title">Edit Color</div>
        <div class="picker-layout">
            <div class="hue-ring-container">
                <canvas class="hue-ring" id="hueRing" width="220" height="220"></canvas>
                <div class="hue-indicator" id="hueIndicator"></div>
                <canvas class="sl-square" id="slSquare" width="90" height="90"></canvas>
                <div class="sl-indicator" id="slIndicator"></div>
            </div>
            <div class="picker-info">
                <div class="picker-preview" id="pickerPreview"></div>
                <div class="picker-value-row" onclick="copyPickerValue('hex')">
                    <span class="label">HEX</span>
                    <span class="value" id="pickerHex">#FF6B6B</span>
                </div>
                <div class="picker-value-row" onclick="copyPickerValue('rgb')">
                    <span class="label">RGB</span>
                    <span class="value" id="pickerRgb">rgb(255,107,107)</span>
                </div>
                <div class="picker-value-row" onclick="copyPickerValue('hsl')">
                    <span class="label">HSL</span>
                    <span class="value" id="pickerHsl">hsl(0,100%,71%)</span>
                </div>
                <div class="picker-btn-row">
                    <button class="picker-btn" onclick="pickerRandom()">Random</button>
                    <button class="picker-btn primary" onclick="closePicker()">Done</button>
                </div>
            </div>
        </div>
    </div>

    <div class="copy-toast" id="copyToast">Copied!</div>

    <!-- Paint mode -->
    <canvas class="paint-overlay" id="paintCanvas"></canvas>
    <div class="paint-controls" id="paintControls">
        <button class="btn active-mode" data-fx="glow" onclick="setFx('glow')">Glow</button>
        <button class="btn" data-fx="ribbon" onclick="setFx('ribbon')">Ribbon</button>
        <button class="btn" data-fx="metaball" onclick="setFx('metaball')">Metaball</button>
        <button class="btn" data-fx="particles" onclick="setFx('particles')">Particles</button>
        <div class="sep"></div>
        <label>Color
            <input type="color" id="paintColor" value="#ff6b6b" style="width:28px;height:22px;border:none;background:none;cursor:pointer;">
        </label>
        <label>Size
            <input type="range" id="brushSize" min="3" max="60" value="20">
            <span class="range-val" id="brushSizeVal">20</span>
        </label>
        <label>Fade
            <input type="range" id="fadeSpeed" min="1" max="20" value="8">
            <span class="range-val" id="fadeSpeedVal">8</span>
        </label>
        <div class="sep"></div>
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="togglePaint()">Exit</button>
    </div>

    <script>
        // ── State ──
        let palette = [];
        let mode = 'harmony'; // 'harmony' or 'free'
        let editingIndex = -1;
        let paintMode = false;
        let dragSourceIndex = -1;

        // Picker state
        let pickerH = 0, pickerS = 100, pickerL = 50;
        let draggingHue = false, draggingSL = false;

        const RING_SIZE = 220;
        const RING_CENTER = RING_SIZE / 2;
        const RING_OUTER = RING_CENTER;
        const RING_INNER = 68;
        const SL_SIZE = 90;
        const RING_MID = (RING_OUTER + RING_INNER) / 2;

        const stripsContainer = document.getElementById('stripsContainer');
        const harmonySelect = document.getElementById('harmonySelect');

        // ── Init palette ──
        function initPalette() {
            const baseH = Math.random() * 360;
            const baseS = 55 + Math.random() * 45;
            const baseL = 35 + Math.random() * 35;
            palette = getHarmonyColors(harmonySelect.value, baseH, baseS, baseL).map(c => ({
                h: c.h, s: c.s, l: c.l, locked: false
            }));
            renderPalette();
        }

        // ── Harmony generation ──
        function getHarmonyColors(type, h, s, l) {
            switch (type) {
                case 'complementary':
                    return [
                        { h, s, l },
                        { h, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h: (h + 180) % 360, s, l },
                        { h: (h + 180) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h, s: s * 0.3, l: 18 },
                    ];
                case 'analogous':
                    return [
                        { h: (h - 30 + 360) % 360, s, l },
                        { h: (h - 15 + 360) % 360, s, l },
                        { h, s, l },
                        { h: (h + 15) % 360, s, l },
                        { h: (h + 30) % 360, s, l },
                    ];
                case 'triadic':
                    return [
                        { h, s, l },
                        { h: (h + 120) % 360, s, l },
                        { h: (h + 240) % 360, s, l },
                        { h: (h + 120) % 360, s: s * 0.5, l: Math.min(l + 22, 92) },
                        { h: (h + 240) % 360, s: s * 0.5, l: Math.min(l + 22, 92) },
                    ];
                case 'split':
                    return [
                        { h, s, l },
                        { h: (h + 150) % 360, s, l },
                        { h: (h + 210) % 360, s, l },
                        { h: (h + 150) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                        { h: (h + 210) % 360, s: s * 0.6, l: Math.min(l + 18, 92) },
                    ];
                case 'monochromatic':
                    return [
                        { h, s, l: 12 },
                        { h, s, l: 28 },
                        { h, s, l },
                        { h, s, l: 68 },
                        { h, s: s * 0.5, l: 85 },
                    ];
            }
        }

        // ── Render ──
        function renderPalette() {
            stripsContainer.innerHTML = '';

            // Add button at start
            if (palette.length < 10) {
                const addFirst = makeAddBtn(0);
                addFirst.style.left = '0';
                addFirst.style.transform = 'translate(0, -50%)';
                stripsContainer.appendChild(addFirst);
            }

            palette.forEach((c, i) => {
                const cs = clamp(c.s, 0, 100);
                const cl = clamp(c.l, 0, 100);
                const rgb = hslToRgb(c.h, cs, cl);
                const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                const textColor = cl > 55 ? 'rgba(0,0,0,0.7)' : 'rgba(255,255,255,0.85)';

                const strip = document.createElement('div');
                strip.className = 'color-strip';
                strip.style.backgroundColor = `hsl(${Math.round(c.h)}, ${Math.round(cs)}%, ${Math.round(cl)}%)`;

                const content = document.createElement('div');
                content.className = 'strip-content';

                // Lock button
                const actions = document.createElement('div');
                actions.className = 'strip-actions';

                const lockBtn = document.createElement('button');
                lockBtn.className = 'strip-action' + (c.locked ? ' locked' : '');
                lockBtn.innerHTML = c.locked ? '&#128274;' : '&#128275;';
                lockBtn.style.color = textColor;
                lockBtn.title = c.locked ? 'Unlock' : 'Lock';
                lockBtn.onclick = (e) => { e.stopPropagation(); toggleLock(i); };

                const editBtn = document.createElement('button');
                editBtn.className = 'strip-action';
                editBtn.innerHTML = '&#9998;';
                editBtn.style.color = textColor;
                editBtn.title = 'Edit color';
                editBtn.onclick = (e) => { e.stopPropagation(); openPicker(i); };

                const removeBtn = document.createElement('button');
                removeBtn.className = 'strip-action';
                removeBtn.innerHTML = '&#10005;';
                removeBtn.style.color = textColor;
                removeBtn.title = 'Remove';
                if (palette.length <= 2) { removeBtn.style.opacity = '0.3'; removeBtn.style.pointerEvents = 'none'; }
                removeBtn.onclick = (e) => { e.stopPropagation(); removeColor(i); };

                const dragBtn = document.createElement('button');
                dragBtn.className = 'strip-drag';
                dragBtn.innerHTML = '&#8942;&#8942;';
                dragBtn.style.color = textColor;
                dragBtn.title = 'Drag to reorder';
                dragBtn.draggable = true;
                dragBtn.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    dragSourceIndex = i;
                    strip.classList.add('dragging');
                });

                strip.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const rect = strip.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                    if (e.clientX < midX) strip.classList.add('drag-over-left');
                    else strip.classList.add('drag-over-right');
                });
                strip.addEventListener('dragleave', () => {
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                });
                strip.addEventListener('drop', (e) => {
                    e.preventDefault();
                    strip.classList.remove('drag-over-left', 'drag-over-right');
                    if (dragSourceIndex === -1) return;
                    const rect = strip.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    let targetIndex = e.clientX < midX ? i : i + 1;
                    if (dragSourceIndex < targetIndex) targetIndex--;
                    if (targetIndex !== dragSourceIndex) {
                        const [moved] = palette.splice(dragSourceIndex, 1);
                        palette.splice(targetIndex, 0, moved);
                    }
                    dragSourceIndex = -1;
                    renderPalette();
                });
                strip.addEventListener('dragend', () => {
                    strip.classList.remove('dragging');
                    dragSourceIndex = -1;
                });

                actions.appendChild(dragBtn);
                actions.appendChild(lockBtn);
                actions.appendChild(editBtn);
                actions.appendChild(removeBtn);

                // Hex display
                const hexEl = document.createElement('div');
                hexEl.className = 'strip-hex';
                hexEl.style.color = textColor;
                hexEl.textContent = hex;
                hexEl.title = 'Click to copy';
                hexEl.onclick = (e) => { e.stopPropagation(); copyHex(hex, hexEl); };

                content.appendChild(actions);
                content.appendChild(hexEl);
                strip.appendChild(content);
                stripsContainer.appendChild(strip);

                // Add button after each strip (between strips)
                if (i < palette.length - 1 && palette.length < 10) {
                    // We'll position add buttons at strip boundaries
                    // Calculate position after rendering
                }
            });

            // Place add-buttons between strips using absolute positioning
            positionAddButtons();
        }

        function positionAddButtons() {
            // Remove old add buttons
            stripsContainer.querySelectorAll('.add-btn').forEach(b => b.remove());
            if (palette.length >= 10) return;

            const strips = stripsContainer.querySelectorAll('.color-strip');
            if (strips.length === 0) return;

            // Add button before first strip
            const firstBtn = makeAddBtn(0);
            firstBtn.style.left = '8px';
            firstBtn.style.transform = 'translate(0, -50%)';
            stripsContainer.appendChild(firstBtn);

            // Add buttons between strips
            strips.forEach((strip, i) => {
                if (i < strips.length - 1) {
                    const btn = makeAddBtn(i + 1);
                    // Position at the right edge of this strip
                    const rect = strip.getBoundingClientRect();
                    const containerRect = stripsContainer.getBoundingClientRect();
                    btn.style.left = (rect.right - containerRect.left) + 'px';
                    stripsContainer.appendChild(btn);
                }
            });

            // Add button after last strip
            const lastBtn = makeAddBtn(palette.length);
            lastBtn.style.right = '8px';
            lastBtn.style.left = 'auto';
            lastBtn.style.transform = 'translate(0, -50%)';
            stripsContainer.appendChild(lastBtn);
        }

        function makeAddBtn(index) {
            const btn = document.createElement('button');
            btn.className = 'add-btn';
            btn.innerHTML = '+';
            btn.title = 'Add color';
            btn.onclick = () => addColor(index);
            return btn;
        }

        // ── Palette actions ──
        function toggleLock(i) {
            palette[i].locked = !palette[i].locked;
            renderPalette();
        }

        function removeColor(i) {
            if (palette.length <= 2) return;
            palette.splice(i, 1);
            renderPalette();
        }

        function addColor(i) {
            if (palette.length >= 10) return;
            const newColor = { h: Math.random() * 360, s: 55 + Math.random() * 45, l: 35 + Math.random() * 35, locked: false };
            palette.splice(i, 0, newColor);
            renderPalette();
        }

        // ── Mode toggle ──
        function toggleMode() {
            const btn = document.getElementById('modeBtn');
            if (mode === 'harmony') {
                mode = 'free';
                btn.textContent = 'Harmony';
                btn.classList.add('active');
                harmonySelect.disabled = true;
                harmonySelect.style.opacity = '0.4';
            } else {
                mode = 'harmony';
                btn.textContent = 'Free Pick';
                btn.classList.remove('active');
                harmonySelect.disabled = false;
                harmonySelect.style.opacity = '1';
                regenerateHarmony();
            }
        }

        function regenerateHarmony() {
            // Use first unlocked color as base, or first color
            const base = palette.find(c => !c.locked) || palette[0];
            const colors = getHarmonyColors(harmonySelect.value, base.h, base.s, base.l);
            for (let i = 0; i < palette.length && i < colors.length; i++) {
                if (!palette[i].locked) {
                    palette[i].h = colors[i].h;
                    palette[i].s = colors[i].s;
                    palette[i].l = colors[i].l;
                }
            }
            renderPalette();
        }

        harmonySelect.addEventListener('change', () => {
            if (mode === 'harmony') regenerateHarmony();
        });

        // ── Spacebar ──
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !paintMode && document.activeElement === document.body) {
                e.preventDefault();
                randomizePalette();
            }
            if (e.code === 'Escape') {
                if (paintMode) togglePaint();
                else if (editingIndex >= 0) closePicker();
            }
        });

        function randomizePalette() {
            if (mode === 'harmony') {
                const baseH = Math.random() * 360;
                const baseS = 55 + Math.random() * 45;
                const baseL = 35 + Math.random() * 35;
                const colors = getHarmonyColors(harmonySelect.value, baseH, baseS, baseL);
                for (let i = 0; i < palette.length; i++) {
                    if (!palette[i].locked && i < colors.length) {
                        palette[i].h = colors[i].h;
                        palette[i].s = colors[i].s;
                        palette[i].l = colors[i].l;
                    }
                }
            } else {
                palette.forEach(c => {
                    if (!c.locked) {
                        c.h = Math.random() * 360;
                        c.s = 55 + Math.random() * 45;
                        c.l = 35 + Math.random() * 35;
                    }
                });
            }
            renderPalette();
        }

        // ── Picker Modal ──
        const hueRing = document.getElementById('hueRing');
        const hueIndicator = document.getElementById('hueIndicator');
        const slSquare = document.getElementById('slSquare');
        const slIndicator = document.getElementById('slIndicator');

        function openPicker(index) {
            editingIndex = index;
            const c = palette[index];
            pickerH = c.h;
            pickerS = c.s;
            pickerL = c.l;
            document.getElementById('pickerBackdrop').classList.add('active');
            document.getElementById('pickerModal').classList.add('active');
            drawHueRing();
            drawSLSquare();
            updatePickerDisplay();
        }

        function closePicker() {
            document.getElementById('pickerBackdrop').classList.remove('active');
            document.getElementById('pickerModal').classList.remove('active');
            editingIndex = -1;
        }

        function applyPickerToStrip() {
            if (editingIndex < 0 || editingIndex >= palette.length) return;
            palette[editingIndex].h = pickerH;
            palette[editingIndex].s = pickerS;
            palette[editingIndex].l = pickerL;

            // In harmony mode, regenerate other colors from edited base
            if (mode === 'harmony') {
                const colors = getHarmonyColors(harmonySelect.value, pickerH, pickerS, pickerL);
                for (let i = 0; i < palette.length && i < colors.length; i++) {
                    if (!palette[i].locked && i !== editingIndex) {
                        palette[i].h = colors[i].h;
                        palette[i].s = colors[i].s;
                        palette[i].l = colors[i].l;
                    }
                }
            }
            renderPalette();
        }

        function pickerRandom() {
            pickerH = Math.random() * 360;
            pickerS = 55 + Math.random() * 45;
            pickerL = 35 + Math.random() * 35;
            drawSLSquare();
            updatePickerDisplay();
            applyPickerToStrip();
        }

        // ── Drawing picker ──
        function drawHueRing() {
            const ctx = hueRing.getContext('2d');
            ctx.clearRect(0, 0, RING_SIZE, RING_SIZE);
            for (let angle = 0; angle < 360; angle += 0.5) {
                const rad = (angle - 90) * Math.PI / 180;
                const rad2 = (angle - 89.5) * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(RING_CENTER + RING_INNER * Math.cos(rad), RING_CENTER + RING_INNER * Math.sin(rad));
                ctx.lineTo(RING_CENTER + RING_OUTER * Math.cos(rad), RING_CENTER + RING_OUTER * Math.sin(rad));
                ctx.lineTo(RING_CENTER + RING_OUTER * Math.cos(rad2), RING_CENTER + RING_OUTER * Math.sin(rad2));
                ctx.lineTo(RING_CENTER + RING_INNER * Math.cos(rad2), RING_CENTER + RING_INNER * Math.sin(rad2));
                ctx.closePath();
                ctx.fillStyle = `hsl(${angle}, 100%, 50%)`;
                ctx.fill();
            }
        }

        function drawSLSquare() {
            const ctx = slSquare.getContext('2d');
            const imageData = ctx.createImageData(SL_SIZE, SL_SIZE);
            for (let y = 0; y < SL_SIZE; y++) {
                for (let x = 0; x < SL_SIZE; x++) {
                    const s = (x / SL_SIZE) * 100;
                    const l = 100 - (y / SL_SIZE) * 100;
                    const rgb = hslToRgb(pickerH, s, l);
                    const i = (y * SL_SIZE + x) * 4;
                    imageData.data[i] = rgb[0];
                    imageData.data[i + 1] = rgb[1];
                    imageData.data[i + 2] = rgb[2];
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updatePickerDisplay() {
            const rgb = hslToRgb(pickerH, pickerS, pickerL);
            const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
            const color = `hsl(${pickerH}, ${pickerS}%, ${pickerL}%)`;

            document.getElementById('pickerPreview').style.backgroundColor = color;
            document.getElementById('pickerHex').textContent = hex;
            document.getElementById('pickerRgb').textContent = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            document.getElementById('pickerHsl').textContent = `hsl(${Math.round(pickerH)}, ${Math.round(pickerS)}%, ${Math.round(pickerL)}%)`;

            // Hue indicator
            const rad = (pickerH - 90) * Math.PI / 180;
            hueIndicator.style.left = (RING_CENTER + RING_MID * Math.cos(rad)) + 'px';
            hueIndicator.style.top = (RING_CENTER + RING_MID * Math.sin(rad)) + 'px';
            hueIndicator.style.backgroundColor = `hsl(${pickerH}, 100%, 50%)`;

            // SL indicator
            const slRect = slSquare.getBoundingClientRect();
            const containerRect = slSquare.parentElement.getBoundingClientRect();
            slIndicator.style.left = (slRect.left - containerRect.left + (pickerS / 100) * SL_SIZE) + 'px';
            slIndicator.style.top = (slRect.top - containerRect.top + ((100 - pickerL) / 100) * SL_SIZE) + 'px';

            applyPickerToStrip();
        }

        // ── Picker interaction ──
        hueRing.addEventListener('mousedown', (e) => { draggingHue = true; pickHue(e); });
        slSquare.addEventListener('mousedown', (e) => { draggingSL = true; pickSL(e); });
        document.addEventListener('mousemove', (e) => {
            if (draggingHue) pickHue(e);
            if (draggingSL) pickSL(e);
        });
        document.addEventListener('mouseup', () => { draggingHue = false; draggingSL = false; });

        function pickHue(e) {
            const rect = hueRing.getBoundingClientRect();
            const x = e.clientX - rect.left - RING_CENTER;
            const y = e.clientY - rect.top - RING_CENTER;
            pickerH = (Math.atan2(y, x) * 180 / Math.PI + 90 + 360) % 360;
            drawSLSquare();
            updatePickerDisplay();
        }

        function pickSL(e) {
            const rect = slSquare.getBoundingClientRect();
            const x = clamp(e.clientX - rect.left, 0, SL_SIZE);
            const y = clamp(e.clientY - rect.top, 0, SL_SIZE);
            pickerS = (x / SL_SIZE) * 100;
            pickerL = 100 - (y / SL_SIZE) * 100;
            updatePickerDisplay();
        }

        // ── Copy ──
        function copyHex(hex, el) {
            navigator.clipboard.writeText(hex);
            showParticles(el);
            showToast(`Copied ${hex}`);
        }

        function copyPickerValue(type) {
            const el = document.getElementById('picker' + type.charAt(0).toUpperCase() + type.slice(1));
            navigator.clipboard.writeText(el.textContent);
            showToast(`Copied ${el.textContent}`);
        }

        function showParticles(el) {
            const rect = el.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const rgb = hslToRgb(pickerH, pickerS, pickerL);
            for (let i = 0; i < 8; i++) {
                const p = document.createElement('div');
                p.className = 'glow-particle';
                const angle = (i / 8) * Math.PI * 2;
                const dist = 35 + Math.random() * 25;
                p.style.left = cx + 'px';
                p.style.top = cy + 'px';
                p.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--dy', Math.sin(angle) * dist + 'px');
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 700);
            }
        }

        function showToast(text) {
            const toast = document.getElementById('copyToast');
            toast.textContent = text;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 1400);
        }

        // ── Paint mode (preserved from original) ──
        const paintCanvas = document.getElementById('paintCanvas');
        const paintCtx = paintCanvas.getContext('2d');
        const paintControls = document.getElementById('paintControls');
        const paintBtn = document.getElementById('paintBtn');
        const brushSizeInput = document.getElementById('brushSize');
        const fadeSpeedInput = document.getElementById('fadeSpeed');
        const paintColorInput = document.getElementById('paintColor');
        let animFrame;
        let currentFx = 'glow';
        let mouseX = 0, mouseY = 0;
        let paintHue = 0, paintSat = 100, paintLight = 50;

        const blobSprite = document.createElement('canvas');
        blobSprite.width = blobSprite.height = 64;
        const bctx = blobSprite.getContext('2d');
        const bg = bctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        bg.addColorStop(0, 'rgba(255,255,255,1)');
        bg.addColorStop(0.4, 'rgba(255,255,255,0.6)');
        bg.addColorStop(1, 'rgba(255,255,255,0)');
        bctx.fillStyle = bg;
        bctx.fillRect(0, 0, 64, 64);

        function syncPaintColor() {
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            paintColorInput.value = rgbToHex(rgb[0], rgb[1], rgb[2]);
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h * 360, s * 100, l * 100];
        }

        paintColorInput.addEventListener('input', (e) => {
            const hex = e.target.value;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            [paintHue, paintSat, paintLight] = rgbToHsl(r, g, b);
        });

        const CHAIN_LEN = 50;
        const chain = [];
        for (let i = 0; i < CHAIN_LEN; i++) chain.push({ x: 0, y: 0 });

        function updateChain() {
            chain[0].x += (mouseX - chain[0].x) * 0.35;
            chain[0].y += (mouseY - chain[0].y) * 0.35;
            for (let i = 1; i < CHAIN_LEN; i++) {
                const ease = 0.32 * (1 - (i / CHAIN_LEN) * 0.6);
                chain[i].x += (chain[i - 1].x - chain[i].x) * ease;
                chain[i].y += (chain[i - 1].y - chain[i].y) * ease;
            }
        }

        const particles = [];
        const MAX_PARTICLES = 400;

        function spawnParticle(x, y) {
            if (particles.length >= MAX_PARTICLES) return;
            const rgb = hslToRgb(paintHue + (Math.random() - 0.5) * 25, paintSat, paintLight);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.3 + Math.random() * 1.5;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 0.5,
                r: rgb[0], g: rgb[1], b: rgb[2],
                life: 1,
                decay: 0.008 + Math.random() * 0.015,
                size: 3 + Math.random() * (parseInt(brushSizeInput.value) * 0.4)
            });
        }

        const streaks = [];
        let streakTimer = 0;

        function spawnStreak() {
            const hueShift = (Math.random() - 0.5) * 50;
            const srgb = hslToRgb((paintHue + hueShift + 360) % 360, paintSat, paintLight);
            const w = paintCanvas.width, h = paintCanvas.height;
            const side = Math.floor(Math.random() * 4);
            let sx, sy, ang;
            if (side === 0) { sx = -10; sy = Math.random() * h; ang = (Math.random() - 0.5) * 0.5; }
            else if (side === 1) { sx = w + 10; sy = Math.random() * h; ang = Math.PI + (Math.random() - 0.5) * 0.5; }
            else if (side === 2) { sx = Math.random() * w; sy = -10; ang = Math.PI / 2 + (Math.random() - 0.5) * 0.5; }
            else { sx = Math.random() * w; sy = h + 10; ang = -Math.PI / 2 + (Math.random() - 0.5) * 0.5; }
            const speed = 2 + Math.random() * 3;
            streaks.push({
                x: sx, y: sy,
                vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed,
                r: srgb[0], g: srgb[1], b: srgb[2],
                size: 2 + Math.random() * 4,
                trail: [], maxTrail: 35 + Math.floor(Math.random() * 50),
                life: 200 + Math.random() * 150, age: 0
            });
        }

        function drawStreaks(ctx) {
            streakTimer++;
            if (streakTimer > 40 + Math.random() * 60) { spawnStreak(); streakTimer = 0; }
            ctx.lineCap = 'round';
            for (let i = streaks.length - 1; i >= 0; i--) {
                const s = streaks[i];
                s.x += s.vx; s.y += s.vy; s.age++;
                s.trail.push({ x: s.x, y: s.y });
                if (s.trail.length > s.maxTrail) s.trail.shift();
                if (s.age > s.life) { streaks.splice(i, 1); continue; }
                const fadeIn = Math.min(1, s.age / 20);
                const fadeOut = s.age > s.life - 30 ? Math.max(0, 1 - (s.age - (s.life - 30)) / 30) : 1;
                const ba = Math.min(fadeIn, fadeOut);
                if (s.trail.length < 3) continue;

                ctx.beginPath();
                ctx.moveTo(s.trail[0].x, s.trail[0].y);
                for (let j = 1; j < s.trail.length - 1; j++) {
                    const xc = (s.trail[j].x + s.trail[j + 1].x) / 2;
                    const yc = (s.trail[j].y + s.trail[j + 1].y) / 2;
                    ctx.quadraticCurveTo(s.trail[j].x, s.trail[j].y, xc, yc);
                }
                ctx.lineWidth = s.size * 5;
                ctx.strokeStyle = `rgba(${s.r}, ${s.g}, ${s.b}, ${ba * 0.06})`;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(s.trail[0].x, s.trail[0].y);
                for (let j = 1; j < s.trail.length - 1; j++) {
                    const xc = (s.trail[j].x + s.trail[j + 1].x) / 2;
                    const yc = (s.trail[j].y + s.trail[j + 1].y) / 2;
                    ctx.quadraticCurveTo(s.trail[j].x, s.trail[j].y, xc, yc);
                }
                ctx.lineWidth = s.size * 1.5;
                ctx.strokeStyle = `rgba(${s.r}, ${s.g}, ${s.b}, ${ba * 0.25})`;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(s.trail[0].x, s.trail[0].y);
                for (let j = 1; j < s.trail.length - 1; j++) {
                    const xc = (s.trail[j].x + s.trail[j + 1].x) / 2;
                    const yc = (s.trail[j].y + s.trail[j + 1].y) / 2;
                    ctx.quadraticCurveTo(s.trail[j].x, s.trail[j].y, xc, yc);
                }
                ctx.lineWidth = s.size * 0.5;
                ctx.strokeStyle = `rgba(${Math.min(255, s.r + 100)}, ${Math.min(255, s.g + 100)}, ${Math.min(255, s.b + 100)}, ${ba * 0.5})`;
                ctx.stroke();

                const headR = s.size * 3.5;
                const headGrad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, headR);
                headGrad.addColorStop(0, `rgba(${Math.min(255, s.r + 80)}, ${Math.min(255, s.g + 80)}, ${Math.min(255, s.b + 80)}, ${ba * 0.5})`);
                headGrad.addColorStop(0.3, `rgba(${s.r}, ${s.g}, ${s.b}, ${ba * 0.15})`);
                headGrad.addColorStop(1, `rgba(${s.r}, ${s.g}, ${s.b}, 0)`);
                ctx.beginPath();
                ctx.arc(s.x, s.y, headR, 0, Math.PI * 2);
                ctx.fillStyle = headGrad;
                ctx.fill();
            }
        }

        function drawGlow(ctx) {
            const size = parseInt(brushSizeInput.value);
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            const r = rgb[0], g = rgb[1], b = rgb[2];
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(chain[0].x, chain[0].y);
            for (let i = 1; i < CHAIN_LEN - 1; i++) {
                const xc = (chain[i].x + chain[i + 1].x) / 2;
                const yc = (chain[i].y + chain[i + 1].y) / 2;
                ctx.quadraticCurveTo(chain[i].x, chain[i].y, xc, yc);
            }
            ctx.lineWidth = size * 3;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.08)`;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(chain[0].x, chain[0].y);
            for (let i = 1; i < CHAIN_LEN - 1; i++) {
                const xc = (chain[i].x + chain[i + 1].x) / 2;
                const yc = (chain[i].y + chain[i + 1].y) / 2;
                ctx.quadraticCurveTo(chain[i].x, chain[i].y, xc, yc);
            }
            ctx.lineWidth = size * 1.4;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.2)`;
            ctx.stroke();

            for (let i = 1; i < CHAIN_LEN - 1; i++) {
                const t = 1 - i / CHAIN_LEN;
                const w = size * t;
                if (w < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(chain[i - 1].x, chain[i - 1].y);
                const xc = (chain[i].x + chain[i + 1].x) / 2;
                const yc = (chain[i].y + chain[i + 1].y) / 2;
                ctx.quadraticCurveTo(chain[i].x, chain[i].y, xc, yc);
                ctx.lineWidth = w;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${t * 0.9})`;
                ctx.stroke();
            }

            const headR = size * 0.6;
            const headGrad = ctx.createRadialGradient(chain[0].x, chain[0].y, 0, chain[0].x, chain[0].y, headR);
            headGrad.addColorStop(0, `rgba(${Math.min(255, r + 120)}, ${Math.min(255, g + 120)}, ${Math.min(255, b + 120)}, 0.95)`);
            headGrad.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.4)`);
            headGrad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            ctx.beginPath();
            ctx.arc(chain[0].x, chain[0].y, headR, 0, Math.PI * 2);
            ctx.fillStyle = headGrad;
            ctx.fill();
        }

        function drawRibbon(ctx) {
            const size = parseInt(brushSizeInput.value);
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            const r = rgb[0], g = rgb[1], b = rgb[2];
            const path1 = [], path2 = [];
            for (let i = 0; i < CHAIN_LEN - 1; i++) {
                const t = 1 - i / CHAIN_LEN;
                const width = size * t * 1.2;
                const dx = chain[Math.min(i + 1, CHAIN_LEN - 1)].x - chain[i].x;
                const dy = chain[Math.min(i + 1, CHAIN_LEN - 1)].y - chain[i].y;
                const angle = Math.atan2(dy, dx);
                const wave = Math.sin(i * 0.12 + Date.now() * 0.002) * width * 0.25;
                const px = Math.cos(angle + Math.PI / 2) * (width + wave);
                const py = Math.sin(angle + Math.PI / 2) * (width + wave);
                path1.push({ x: chain[i].x + px, y: chain[i].y + py });
                path2.push({ x: chain[i].x - px, y: chain[i].y - py });
            }
            ctx.beginPath();
            ctx.moveTo(path1[0].x, path1[0].y);
            for (let i = 1; i < path1.length - 1; i++) {
                const xc = (path1[i].x + path1[i + 1].x) / 2;
                const yc = (path1[i].y + path1[i + 1].y) / 2;
                ctx.quadraticCurveTo(path1[i].x, path1[i].y, xc, yc);
            }
            for (let i = path2.length - 1; i > 0; i--) {
                const xc = (path2[i].x + path2[i - 1].x) / 2;
                const yc = (path2[i].y + path2[i - 1].y) / 2;
                ctx.quadraticCurveTo(path2[i].x, path2[i].y, xc, yc);
            }
            ctx.closePath();
            const grad = ctx.createLinearGradient(chain[0].x, chain[0].y, chain[CHAIN_LEN - 1].x, chain[CHAIN_LEN - 1].y);
            grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.6)`);
            grad.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.25)`);
            grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.lineCap = 'round';
            for (const path of [path1, path2]) {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length - 1; i++) {
                    const xc = (path[i].x + path[i + 1].x) / 2;
                    const yc = (path[i].y + path[i + 1].y) / 2;
                    ctx.quadraticCurveTo(path[i].x, path[i].y, xc, yc);
                }
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.25)`;
                ctx.stroke();
            }
        }

        const blobs = [];
        for (let i = 0; i < 8; i++) blobs.push({
            x: 0, y: 0,
            baseSize: 12 + Math.random() * 18,
            orbitSpeed: 0.0008 + Math.random() * 0.0012,
            orbitOffset: (i / 8) * Math.PI * 2,
            lag: 0.04 + i * 0.012
        });

        function drawMetaball(ctx) {
            const size = parseInt(brushSizeInput.value);
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            const r = rgb[0], g = rgb[1], b = rgb[2];
            const now = Date.now();
            blobs.forEach((bl) => {
                const angle = bl.orbitOffset + now * bl.orbitSpeed;
                const spread = size * 0.8 + size * 0.4 * Math.sin(now * 0.001 + bl.orbitOffset);
                const targetX = mouseX + Math.cos(angle) * spread;
                const targetY = mouseY + Math.sin(angle) * spread;
                bl.x += (targetX - bl.x) * bl.lag;
                bl.y += (targetY - bl.y) * bl.lag;
            });
            ctx.globalCompositeOperation = 'lighter';
            blobs.forEach(bl => {
                const radius = (bl.baseSize / 18) * size;
                const grad = ctx.createRadialGradient(bl.x, bl.y, 0, bl.x, bl.y, radius);
                grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.55)`);
                grad.addColorStop(0.45, `rgba(${r}, ${g}, ${b}, 0.2)`);
                grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.beginPath();
                ctx.arc(bl.x, bl.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            });
            const mainR = size * 0.7;
            const mainGrad = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, mainR);
            mainGrad.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.85)`);
            mainGrad.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.3)`);
            mainGrad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, mainR, 0, Math.PI * 2);
            ctx.fillStyle = mainGrad;
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawParticles(ctx) {
            const size = parseInt(brushSizeInput.value);
            for (let i = 0; i < 3; i++) spawnParticle(mouseX + (Math.random() - 0.5) * size, mouseY + (Math.random() - 0.5) * size);
            ctx.globalCompositeOperation = 'lighter';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.vy += 0.015; p.vx *= 0.995;
                p.life -= p.decay;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                const s = p.size * p.life;
                ctx.globalAlpha = p.life * 0.7;
                ctx.drawImage(blobSprite, p.x - s, p.y - s, s * 2, s * 2);
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'multiply';
            const rgb = hslToRgb(paintHue, paintSat, paintLight);
            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            ctx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        brushSizeInput.addEventListener('input', () => {
            document.getElementById('brushSizeVal').textContent = brushSizeInput.value;
        });
        fadeSpeedInput.addEventListener('input', () => {
            document.getElementById('fadeSpeedVal').textContent = fadeSpeedInput.value;
        });

        function setFx(fx) {
            currentFx = fx;
            document.querySelectorAll('.paint-controls .btn[data-fx]').forEach(b => {
                b.classList.toggle('active-mode', b.dataset.fx === fx);
            });
            clearCanvas();
        }

        function togglePaint() {
            paintMode = !paintMode;
            paintCanvas.classList.toggle('active', paintMode);
            paintControls.classList.toggle('active', paintMode);
            paintBtn.classList.toggle('active', paintMode);
            if (paintMode) {
                // Use first palette color for paint
                if (palette.length > 0) {
                    paintHue = palette[0].h;
                    paintSat = palette[0].s;
                    paintLight = palette[0].l;
                }
                syncPaintColor();
                resizePaintCanvas();
                clearCanvas();
                chain.forEach(p => { p.x = mouseX; p.y = mouseY; });
                blobs.forEach(b => { b.x = mouseX; b.y = mouseY; });
                animFrame = requestAnimationFrame(paintLoop);
            } else {
                cancelAnimationFrame(animFrame);
            }
        }

        function resizePaintCanvas() {
            paintCanvas.width = window.innerWidth;
            paintCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', () => {
            resizePaintCanvas();
            renderPalette();
        });
        resizePaintCanvas();

        paintCanvas.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });

        function paintLoop() {
            if (currentFx === 'particles') {
                const fade = parseInt(fadeSpeedInput.value);
                paintCtx.fillStyle = `rgba(15, 15, 26, ${fade / 300})`;
                paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            } else {
                paintCtx.fillStyle = '#0f0f1a';
                paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            }
            updateChain();
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            switch (currentFx) {
                case 'glow': drawGlow(paintCtx); break;
                case 'ribbon': drawRibbon(paintCtx); break;
                case 'metaball': drawMetaball(paintCtx); break;
                case 'particles': drawParticles(paintCtx); break;
            }
            drawStreaks(paintCtx);
            animFrame = requestAnimationFrame(paintLoop);
        }

        function clearCanvas() {
            paintCtx.fillStyle = '#0f0f1a';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            particles.length = 0;
            streaks.length = 0;
        }

        // ── Color math ──
        function hslToRgb(h, s, l) {
            s /= 100; l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = (n) => {
                const k = (n + h / 30) % 12;
                return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            };
            return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0').toUpperCase()).join('');
        }

        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

        // ── Init ──
        initPalette();
    </script>
</body>
</html>
